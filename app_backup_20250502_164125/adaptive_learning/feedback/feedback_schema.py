"""
Schema definitions for feedback data in the Adaptive Learning System.

This module defines the structure and validation rules for feedback data
used throughout the Adaptive Learning System.
"""

from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, field


@dataclass
class RatingFeedback:
    """Schema for rating-based feedback."""
    
    # Overall rating (typically 1-5)
    overall: int
    
    # Optional aspect-specific ratings
    aspects: Dict[str, int] = field(default_factory=dict)
    
    # Scale information (e.g., 1-5, 1-10)
    scale: Dict[str, int] = field(default_factory=lambda: {"min": 1, "max": 5})


@dataclass
class TextFeedback:
    """Schema for text-based feedback."""
    
    # General comment
    comment: str
    
    # Optional categorization
    category: Optional[str] = None
    
    # Optional sentiment (if pre-analyzed)
    sentiment: Optional[str] = None


@dataclass
class AspectFeedback:
    """Schema for aspect-specific feedback."""
    
    # Aspect name
    name: str
    
    # Rating for this aspect
    rating: int
    
    # Optional comment about this aspect
    comment: Optional[str] = None


@dataclass
class ImprovementFeedback:
    """Schema for improvement suggestions."""
    
    # Suggestion text
    suggestion: str
    
    # Optional area for improvement
    area: Optional[str] = None
    
    # Optional priority (low, medium, high)
    priority: Optional[str] = None


@dataclass
class FeedbackContext:
    """Context information for feedback."""
    
    # Interaction details
    interaction_id: str
    task_type: Optional[str] = None
    
    # User details
    user_id: str
    user_experience_level: Optional[str] = None
    
    # Timing information
    interaction_timestamp: Optional[str] = None
    feedback_timestamp: Optional[str] = None


@dataclass
class FeedbackSchema:
    """Complete schema for feedback data."""
    
    # Required context
    context: FeedbackContext
    
    # Feedback ID (generated by system)
    feedback_id: Optional[str] = None
    
    # Optional feedback components
    rating: Optional[RatingFeedback] = None
    text: Optional[TextFeedback] = None
    aspects: List[AspectFeedback] = field(default_factory=list)
    improvements: List[ImprovementFeedback] = field(default_factory=list)
    
    # Metadata
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the feedback schema to a dictionary."""
        result = {
            "context": {
                "interaction_id": self.context.interaction_id,
                "user_id": self.context.user_id,
            }
        }
        
        if self.context.task_type:
            result["context"]["task_type"] = self.context.task_type
        
        if self.context.user_experience_level:
            result["context"]["user_experience_level"] = self.context.user_experience_level
        
        if self.context.interaction_timestamp:
            result["context"]["interaction_timestamp"] = self.context.interaction_timestamp
        
        if self.context.feedback_timestamp:
            result["context"]["feedback_timestamp"] = self.context.feedback_timestamp
        
        if self.feedback_id:
            result["feedback_id"] = self.feedback_id
        
        if self.rating:
            result["rating"] = {
                "overall": self.rating.overall,
                "scale": self.rating.scale,
            }
            if self.rating.aspects:
                result["rating"]["aspects"] = self.rating.aspects
        
        if self.text:
            result["text"] = {
                "comment": self.text.comment,
            }
            if self.text.category:
                result["text"]["category"] = self.text.category
            if self.text.sentiment:
                result["text"]["sentiment"] = self.text.sentiment
        
        if self.aspects:
            result["aspects"] = [
                {
                    "name": aspect.name,
                    "rating": aspect.rating,
                    **({"comment": aspect.comment} if aspect.comment else {}),
                }
                for aspect in self.aspects
            ]
        
        if self.improvements:
            result["improvements"] = [
                {
                    "suggestion": improvement.suggestion,
                    **({"area": improvement.area} if improvement.area else {}),
                    **({"priority": improvement.priority} if improvement.priority else {}),
                }
                for improvement in self.improvements
            ]
        
        if self.metadata:
            result["metadata"] = self.metadata
        
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'FeedbackSchema':
        """Create a FeedbackSchema instance from a dictionary."""
        context_data = data.get("context", {})
        context = FeedbackContext(
            interaction_id=context_data.get("interaction_id", ""),
            user_id=context_data.get("user_id", ""),
            task_type=context_data.get("task_type"),
            user_experience_level=context_data.get("user_experience_level"),
            interaction_timestamp=context_data.get("interaction_timestamp"),
            feedback_timestamp=context_data.get("feedback_timestamp"),
        )
        
        rating_data = data.get("rating")
        rating = None
        if rating_data:
            rating = RatingFeedback(
                overall=rating_data.get("overall", 0),
                aspects=rating_data.get("aspects", {}),
                scale=rating_data.get("scale", {"min": 1, "max": 5}),
            )
        
        text_data = data.get("text")
        text = None
        if text_data:
            text = TextFeedback(
                comment=text_data.get("comment", ""),
                category=text_data.get("category"),
                sentiment=text_data.get("sentiment"),
            )
        
        aspects = []
        for aspect_data in data.get("aspects", []):
            aspects.append(AspectFeedback(
                name=aspect_data.get("name", ""),
                rating=aspect_data.get("rating", 0),
                comment=aspect_data.get("comment"),
            ))
        
        improvements = []
        for improvement_data in data.get("improvements", []):
            improvements.append(ImprovementFeedback(
                suggestion=improvement_data.get("suggestion", ""),
                area=improvement_data.get("area"),
                priority=improvement_data.get("priority"),
            ))
        
        return cls(
            context=context,
            feedback_id=data.get("feedback_id"),
            rating=rating,
            text=text,
            aspects=aspects,
            improvements=improvements,
            metadata=data.get("metadata", {}),
        )
